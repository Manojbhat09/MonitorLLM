import os
import logging
import re
from datetime import datetime
from colorama import Fore, Style
from .commands import change_directory, run_command_with_pty
from .ssh import run_interactive_ssh
from .prompt import get_prompt
from .activity_monitor import TerminalActivityMonitor
from models.openai_model import OpenAIModel
from models.groq_model import GroqModel
from models.ollama_model import OllamaModel

logger = logging.getLogger(__name__)

class SheLLM:
    def __init__(self, llm_api, ollama_host="http://localhost:11434", ollama_model="llama3.1"):
        self.context = ""
        self.history = []
        self.current_process_pid = None
        self.activity_monitor = TerminalActivityMonitor()
        
        if llm_api == 'groq':
            self.model = GroqModel()
        elif llm_api == 'ollama':
            self.model = OllamaModel(model_name=ollama_model, host=ollama_host)
        else:
            self.model = OpenAIModel()
        
        self.ssh_session = None
        logger.info(f"SheLLM initialized with {llm_api} model.")

    def update_context(self, output):
        """Updates the context with new terminal output."""
        self.context += output + "\n"
        logger.debug(f"Updated context: {self.context}")

    def execute_system_command(self, command):
        """Executes system commands and captures output."""
        if not command.strip():
            logger.info("No command entered. Please enter a valid command.")
            return
        
        # Log command execution
        self.activity_monitor.log_command(command)
        
        tokens = command.split()
        if tokens[0] == 'cd':
            old_dir = os.getcwd()
            change_directory(tokens)
            new_dir = os.getcwd()
            if old_dir != new_dir:
                self.activity_monitor.log_directory_change(new_dir)
        elif tokens[0] == 'history':
            self.show_history()
        elif tokens[0] == 'ssh':
            run_interactive_ssh(tokens, self)
        else:
            output = run_command_with_pty(command)
            self.update_context(output)
            # Log command output
            self.activity_monitor.log_output(output, command)
            
            # Log file operations if detected
            self._detect_file_operations(command, output)

    def handle_lm_command(self, command, remote=False):
        """Handles commands generated by the language model."""
        while True:
            # Use enhanced context from activity monitor
            enhanced_context = self.activity_monitor.get_context()
            suggestion = self.model.get_command_suggestion(enhanced_context, command)
            if suggestion:
                current_time = datetime.now().strftime('%H:%M:%S')
                logger.info(f"Execute command: {Fore.RED}{suggestion}{Style.RESET_ALL}")
                response = input(f"{Fore.RED}[SheLLM]{Style.RESET_ALL} Confirm execution (Y/n/r)").lower()
                if response == 'y':
                    if remote and self.ssh_session:
                        os.write(self.ssh_session, (suggestion + '\n').encode())
                    else:
                        self.execute_system_command(suggestion)
                    break
                elif response == 'n':
                    break
                elif response == 'r':
                    continue

    def answer_question(self, question):
        """Answers a question using the language model."""
        # Use enhanced context from activity monitor
        enhanced_context = self.activity_monitor.get_context()
        answer = self.model.answer_question(enhanced_context, question)
        current_time = datetime.now().strftime('%H:%M:%S')
        logger.info(f"{Fore.RED}[SheLLM]{Style.RESET_ALL} {Fore.BLUE}[{current_time}]{Style.RESET_ALL} Answer: {Fore.GREEN}{answer}{Style.RESET_ALL}")
        return answer

    def show_history(self):
        """Shows the command history."""
        current_time = datetime.now().strftime('%H:%M:%S')
        if not self.history:
            logger.info(f"{Fore.RED}[SheLLM]{Style.RESET_ALL} {Fore.BLUE}[{current_time}]{Style.RESET_ALL} No command history.")
        else:
            logger.info(f"{Fore.RED}[SheLLM]{Style.RESET_ALL} {Fore.BLUE}[{current_time}]{Style.RESET_ALL} Command History:")
            for i, cmd in enumerate(self.history, 1):
                logger.info(f"{i}: {cmd}")

    def chat_with_context(self, message):
        """Enhanced chat function with file reference support."""
        # Parse file references
        file_contents = self.activity_monitor.parse_file_references(message)
        
        # Get context
        context = self.activity_monitor.get_context()
        
        # Generate response
        if hasattr(self.model, 'chat_with_context'):
            response = self.model.chat_with_context(context, message, file_contents)
        else:
            # Fallback for models without chat_with_context
            response = self.model.answer_question(context, message)
        
        current_time = datetime.now().strftime('%H:%M:%S')
        logger.info(f"{Fore.RED}[SheLLM]{Style.RESET_ALL} {Fore.BLUE}[{current_time}]{Style.RESET_ALL} Response: {Fore.GREEN}{response}{Style.RESET_ALL}")
        return response

    def _detect_file_operations(self, command, output):
        """Detect file operations from command and output."""
        file_op_patterns = {
            'create': [r'touch\s+(.+)', r'echo.*>\s*(.+)', r'cat.*>\s*(.+)'],
            'edit': [r'nano\s+(.+)', r'vim\s+(.+)', r'emacs\s+(.+)', r'code\s+(.+)'],
            'delete': [r'rm\s+(.+)', r'rmdir\s+(.+)'],
            'copy': [r'cp\s+\S+\s+(.+)', r'scp\s+\S+\s+(.+)'],
            'move': [r'mv\s+\S+\s+(.+)']
        }
        
        for operation, patterns in file_op_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, command)
                for match in matches:
                    # Clean up the filepath
                    filepath = match.strip().split()[0]  # Take first part if multiple files
                    self.activity_monitor.log_file_operation(operation, filepath)

    def get_session_summary(self):
        """Get session summary from activity monitor."""
        return self.activity_monitor.get_session_summary()

    def save_session(self, filepath=None):
        """Save current session."""
        return self.activity_monitor.save_session(filepath)
